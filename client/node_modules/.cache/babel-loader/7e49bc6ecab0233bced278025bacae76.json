{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport React from 'react';\nimport Element from './Element';\nimport { FILTER_DENY, FILTER_CAST_NUMBER, FILTER_CAST_BOOL, TAGS, TAGS_BLACKLIST, ATTRIBUTES, ATTRIBUTES_TO_PROPS, TYPE_INLINE, TYPE_BLOCK, CONFIG_BLOCK } from './constants';\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar INVALID_ROOTS = ['<!DOC', '<HTML', '<HEAD', '<BODY'];\nvar ROOT_COMPARE_LENGTH = 5;\nvar ARIA_COMPARE_LENGTH = 5;\n\nvar Parser = function () {\n  function Parser(markup) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var matchers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var filters = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n    _classCallCheck(this, Parser);\n\n    _defineProperty(this, \"doc\", void 0);\n\n    _defineProperty(this, \"content\", []);\n\n    _defineProperty(this, \"props\", void 0);\n\n    _defineProperty(this, \"matchers\", void 0);\n\n    _defineProperty(this, \"filters\", void 0);\n\n    _defineProperty(this, \"keyIndex\", void 0);\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (markup && typeof markup !== 'string') {\n        throw new TypeError('Interweave parser requires a valid string.');\n      }\n    }\n\n    this.props = props;\n    this.matchers = matchers;\n    this.filters = filters;\n    this.keyIndex = -1;\n    this.doc = this.createDocument(markup || '');\n  }\n\n  _createClass(Parser, [{\n    key: \"applyAttributeFilters\",\n    value: function applyAttributeFilters(name, value) {\n      return this.filters.reduce(function (nextValue, filter) {\n        return typeof filter.attribute === 'function' ? filter.attribute(name, nextValue) : nextValue;\n      }, value);\n    }\n  }, {\n    key: \"applyNodeFilters\",\n    value: function applyNodeFilters(name, node) {\n      return this.filters.reduce(function (nextNode, filter) {\n        return nextNode && typeof filter.node === 'function' ? filter.node(name, nextNode) : nextNode;\n      }, node);\n    }\n  }, {\n    key: \"applyMatchers\",\n    value: function applyMatchers(string, parentConfig) {\n      var _this = this;\n\n      var elements = [];\n      var props = this.props;\n      var matchedString = string;\n      var parts = null;\n      this.matchers.forEach(function (matcher) {\n        var tagName = matcher.asTag().toLowerCase();\n\n        var config = _this.getTagConfig(tagName);\n\n        if (props[matcher.inverseName] || TAGS_BLACKLIST[tagName] || !props.disableWhitelist && !TAGS[tagName]) {\n          return;\n        }\n\n        if (!_this.canRenderChild(parentConfig, config)) {\n          return;\n        }\n\n        while (parts = matcher.match(matchedString)) {\n          var _ref = parts,\n              match = _ref.match,\n              partProps = _objectWithoutProperties(_ref, [\"match\"]);\n\n          matchedString = matchedString.replace(match, \"#{{\".concat(elements.length, \"}}#\"));\n          _this.keyIndex += 1;\n          var element = matcher.createElement(match, _objectSpread({}, props, partProps, {\n            key: _this.keyIndex\n          }));\n\n          if (element) {\n            elements.push(element);\n          }\n        }\n      });\n\n      if (elements.length === 0) {\n        return matchedString;\n      }\n\n      var matchedArray = [];\n      var lastIndex = 0;\n\n      while (parts = matchedString.match(/#\\{\\{(\\d+)\\}\\}#/)) {\n        var _ref2 = parts,\n            _ref3 = _slicedToArray(_ref2, 2),\n            no = _ref3[1];\n\n        var _ref4 = parts,\n            _ref4$index = _ref4.index,\n            index = _ref4$index === void 0 ? 0 : _ref4$index;\n\n        if (lastIndex !== index) {\n          matchedArray.push(matchedString.slice(lastIndex, index));\n        }\n\n        matchedArray.push(elements[parseInt(no, 10)]);\n        lastIndex = index + parts[0].length;\n        matchedString = matchedString.replace(\"#{{\".concat(no, \"}}#\"), \"%{{\".concat(no, \"}}%\"));\n      }\n\n      if (lastIndex < matchedString.length) {\n        matchedArray.push(matchedString.slice(lastIndex));\n      }\n\n      return matchedArray;\n    }\n  }, {\n    key: \"canRenderChild\",\n    value: function canRenderChild(parentConfig, childConfig) {\n      if (!parentConfig.tagName || !childConfig.tagName) {\n        return false;\n      }\n\n      if (parentConfig.children && parentConfig.children.length > 0 && parentConfig.children.indexOf(childConfig.tagName) === -1) {\n        return false;\n      }\n\n      if (childConfig.parent && childConfig.parent.length > 0 && childConfig.parent.indexOf(parentConfig.tagName) === -1) {\n        return false;\n      }\n\n      if (!parentConfig.self && parentConfig.tagName === childConfig.tagName) {\n        return false;\n      }\n\n      if (!parentConfig.block && childConfig.type === TYPE_BLOCK) {\n        return false;\n      }\n\n      if (!parentConfig.inline && childConfig.type === TYPE_INLINE) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"convertLineBreaks\",\n    value: function convertLineBreaks(markup) {\n      var _this$props = this.props,\n          noHtml = _this$props.noHtml,\n          disableLineBreaks = _this$props.disableLineBreaks;\n\n      if (noHtml || disableLineBreaks || markup.match(/<((?:\\/[a-z ]+)|(?:[a-z ]+\\/))>/gi)) {\n        return markup;\n      }\n\n      var nextMarkup = markup.replace(/\\r\\n/g, '\\n');\n      nextMarkup = nextMarkup.replace(/\\n{3,}/g, '\\n\\n\\n');\n      nextMarkup = nextMarkup.replace(/\\n/g, '<br/>');\n      return nextMarkup;\n    }\n  }, {\n    key: \"createDocument\",\n    value: function createDocument(markup) {\n      var doc = document.implementation.createHTMLDocument('Interweave');\n\n      if (INVALID_ROOTS.indexOf(markup.substr(0, ROOT_COMPARE_LENGTH).toUpperCase()) >= 0) {\n        if (\"production\" !== process.env.NODE_ENV) {\n          throw new Error('HTML documents as Interweave content are not supported.');\n        }\n      } else {\n        doc.body.innerHTML = this.convertLineBreaks(markup);\n      }\n\n      return doc;\n    }\n  }, {\n    key: \"extractAttributes\",\n    value: function extractAttributes(node) {\n      var _this2 = this;\n\n      var disableWhitelist = this.props.disableWhitelist;\n      var attributes = {};\n      var count = 0;\n\n      if (node.nodeType !== ELEMENT_NODE || !node.attributes) {\n        return null;\n      }\n\n      Array.from(node.attributes).forEach(function (attr) {\n        var name = attr.name,\n            value = attr.value;\n        var newName = name.toLowerCase();\n        var filter = ATTRIBUTES[newName] || ATTRIBUTES[name];\n\n        if (!_this2.isSafe(node)) {\n          return;\n        }\n\n        if (newName.slice(0, ARIA_COMPARE_LENGTH) !== 'aria-') {\n          if (!disableWhitelist && (!filter || filter === FILTER_DENY) || newName.match(/^on/) || value.replace(/(\\s|\\0|&#x0(9|A|D);)/, '').match(/(javascript|vbscript|livescript|xss):/i)) {\n            return;\n          }\n        }\n\n        var newValue = _this2.applyAttributeFilters(newName, value);\n\n        if (filter === FILTER_CAST_BOOL) {\n          newValue = true;\n        } else if (filter === FILTER_CAST_NUMBER) {\n          newValue = parseFloat(newValue);\n        } else {\n          newValue = String(newValue);\n        }\n\n        attributes[ATTRIBUTES_TO_PROPS[newName] || newName] = newValue;\n        count += 1;\n      });\n\n      if (count === 0) {\n        return null;\n      }\n\n      return attributes;\n    }\n  }, {\n    key: \"getTagConfig\",\n    value: function getTagConfig(tagName) {\n      if (TAGS[tagName]) {\n        return _objectSpread({}, TAGS[tagName], {\n          tagName: tagName\n        });\n      }\n\n      return {};\n    }\n  }, {\n    key: \"isSafe\",\n    value: function isSafe(node) {\n      if (typeof HTMLAnchorElement !== 'undefined' && node instanceof HTMLAnchorElement) {\n        var href = node.getAttribute('href');\n\n        if (href && href.charAt(0) === '#') {\n          return true;\n        }\n\n        var protocol = node.protocol.toLowerCase();\n        return protocol === ':' || protocol === 'http:' || protocol === 'https:' || protocol === 'mailto:';\n      }\n\n      return true;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      return this.parseNode(this.doc.body, _objectSpread({}, CONFIG_BLOCK, {\n        tagName: 'body'\n      }));\n    }\n  }, {\n    key: \"parseNode\",\n    value: function parseNode(parentNode, parentConfig) {\n      var _this3 = this;\n\n      var _this$props2 = this.props,\n          noHtml = _this$props2.noHtml,\n          noHtmlExceptMatchers = _this$props2.noHtmlExceptMatchers,\n          disableWhitelist = _this$props2.disableWhitelist,\n          transform = _this$props2.transform;\n      var content = [];\n      var mergedText = '';\n      Array.from(parentNode.childNodes).forEach(function (node) {\n        if (node.nodeType === ELEMENT_NODE) {\n          var tagName = node.nodeName.toLowerCase();\n\n          var config = _this3.getTagConfig(tagName);\n\n          if (mergedText) {\n            content.push(mergedText);\n            mergedText = '';\n          }\n\n          var nextNode = _this3.applyNodeFilters(tagName, node);\n\n          if (!nextNode) {\n            return;\n          }\n\n          var children;\n\n          if (transform) {\n            _this3.keyIndex += 1;\n            var _key = _this3.keyIndex;\n            children = _this3.parseNode(nextNode, config);\n            var transformed = transform(nextNode, children, config);\n\n            if (transformed === null) {\n              return;\n            } else if (typeof transformed !== 'undefined') {\n              content.push(React.cloneElement(transformed, {\n                key: _key\n              }));\n              return;\n            }\n\n            _this3.keyIndex = _key - 1;\n          }\n\n          if (TAGS_BLACKLIST[tagName]) {\n            return;\n          }\n\n          if (!(noHtml || noHtmlExceptMatchers && tagName !== 'br') && (disableWhitelist || _this3.canRenderChild(parentConfig, config))) {\n            _this3.keyIndex += 1;\n\n            var attributes = _this3.extractAttributes(nextNode);\n\n            var elementProps = {\n              tagName: tagName\n            };\n\n            if (attributes) {\n              elementProps.attributes = attributes;\n            }\n\n            if (config.void) {\n              elementProps.selfClose = config.void;\n            }\n\n            content.push(React.createElement(Element, _objectSpread({}, elementProps, {\n              key: _this3.keyIndex\n            }), children || _this3.parseNode(nextNode, config)));\n          } else {\n            content = content.concat(_this3.parseNode(nextNode, config.tagName ? config : parentConfig));\n          }\n        } else if (node.nodeType === TEXT_NODE) {\n          var text = noHtml && !noHtmlExceptMatchers ? node.textContent : _this3.applyMatchers(node.textContent || '', parentConfig);\n\n          if (Array.isArray(text)) {\n            content = content.concat(text);\n          } else {\n            mergedText += text;\n          }\n        }\n      });\n\n      if (mergedText) {\n        content.push(mergedText);\n      }\n\n      return content;\n    }\n  }]);\n\n  return Parser;\n}();\n\nexport { Parser as default };","map":null,"metadata":{},"sourceType":"module"}